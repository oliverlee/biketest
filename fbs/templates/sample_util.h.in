// This file is autogenerated.
// Do not modify this file as changes may be overwritten.
// Generated with settings: {{ size }}

{%- macro vector(field, rows) -%}
{%- for i in range(size[rows]) %}
{%- if not loop.last %}
    {{ field }}({{ i }}),
{%- else %}
    {{ field }}({{ i }})
{%- endif %}
{%- endfor %}
{%- endmacro %}

{%- macro matrix(field, rows, cols) -%}
{%- for i in range(size[rows]) %}
{%- set iloop = loop %}
{%- for j in range(size[cols]) %}
{%- if not (iloop.last and loop.last) %}
    {{ field }}({{ i }}, {{ j }}),
{%- else %}
    {{ field }}({{ i }}, {{ j }})
{%- endif %}
{%- endfor %}
{%- endfor %}
{%- endmacro %}

{%- macro symmetric(field, rows) -%}
{%- for i in range(size[rows]) %}
{%- set iloop = loop %}
{%- for j in range(size[rows]) if j >= i %}
{%- if not (iloop.last and loop.last) %}
    {{ field }}({{ i }}, {{ j }}),
{%- else %}
    {{ field }}({{ i }}, {{ j }})
{%- endif %}
{%- endfor %}
{%- endfor %}
{%- endmacro %}

#pragma once
#include "bicycle/whipple.h"
#include "kalman.h"
#include "lqr.h"
#include "sample_generated.h"

namespace fbs {

// TODO: generate per Linear or DiscreteLinear derived class
::fbs::State state(const model::BicycleWhipple::state_t& x) {
    return ::fbs::State({{ vector('x', 'n') }});
}

::fbs::Input input(const model::BicycleWhipple::input_t& u) {
    return ::fbs::Input({{ vector('u', 'm') }});
}

::fbs::Output output(const model::BicycleWhipple::output_t& y) {
    return ::fbs::Output({{ vector('y', 'l') }});
}

::fbs::AuxiliaryState auxiliary_state(const model::BicycleWhipple::auxiliary_state_t& x) {
    return ::fbs::AuxiliaryState({{ vector('x', 'p') }});
}

::fbs::StateMatrix state_matrix(const model::BicycleWhipple::state_matrix_t& a) {
    return ::fbs::StateMatrix({{ matrix('a', 'n', 'n') }});
}

::fbs::InputMatrix input_matrix(const model::BicycleWhipple::input_matrix_t& b) {
    return ::fbs::InputMatrix({{ matrix('b', 'n', 'm') }});
}

::fbs::OutputMatrix output_matrix(const model::BicycleWhipple::output_matrix_t& c) {
    return ::fbs::OutputMatrix({{ matrix('c', 'l', 'n') }});
}

::fbs::FeedthroughMatrix feedthrough_matrix(const model::BicycleWhipple::feedthrough_matrix_t& d) {
    return ::fbs::FeedthroughMatrix({{ matrix('d', 'l', 'm') }});
}

::fbs::SymmetricStateMatrix symmetric_state_matrix(const model::BicycleWhipple::state_matrix_t& m) {
    return ::fbs::SymmetricStateMatrix({{ symmetric('m', 'n') }});
}

::fbs::SymmetricInputMatrix symmetric_input_matrix(const controller::Lqr<model::BicycleWhipple>::input_cost_t& m) {
    return ::fbs::SymmetricInputMatrix({{ symmetric('m', 'm') }});
}

::fbs::SymmetricOutputMatrix symmetric_output_matrix(
        const observer::Kalman<model::BicycleWhipple>::measurement_noise_covariance_t& m) {
    return ::fbs::SymmetricOutputMatrix({{ symmetric('m', 'l') }});
}

::fbs::SecondOrderMatrix second_order_matrix(const model::BicycleWhipple::second_order_matrix_t& m) {
    return ::fbs::SecondOrderMatrix({{ matrix('m', 'o', 'o') }});
}

::fbs::KalmanGainMatrix kalman_gain_matrix(const observer::Kalman<model::BicycleWhipple>::kalman_gain_t& k) {
    return ::fbs::KalmanGainMatrix({{ matrix('k', 'n', 'l') }});
}

::fbs::LqrGainMatrix lqr_gain_matrix(const controller::Lqr<model::BicycleWhipple>::lqr_gain_t& k) {
    return ::fbs::LqrGainMatrix({{ matrix('k', 'm', 'n') }});
}


flatbuffers::Offset<::fbs::Bicycle> create_bicycle(
        flatbuffers::FlatBufferBuilder& fbb,
        const model::BicycleWhipple& bicycle, bool v = true,
        bool M = true, bool C1 = true, bool K0 = true, bool K2 = true,
        bool A = true, bool B = true, bool C = true, bool D = true) {
    double v_ = 0;
    auto M_ = second_order_matrix(bicycle.M());
    auto C1_ = second_order_matrix(bicycle.C1());
    auto K0_ = second_order_matrix(bicycle.K0());
    auto K2_ = second_order_matrix(bicycle.K2());
    auto A_ = state_matrix(bicycle.A());
    auto B_ = input_matrix(bicycle.B());
    auto C_ = output_matrix(bicycle.C());
    auto D_ = feedthrough_matrix(bicycle.D());
    auto Mp = &M_;
    auto C1p = &C1_;
    auto K0p = &K0_;
    auto K2p = &K2_;
    auto Ap = &A_;
    auto Bp = &B_;
    auto Cp = &C_;
    auto Dp = &D_;

    if (v) {
        v_ = bicycle.v();
    }
    if (!M) {
        Mp = nullptr;
    }
    if (!C1) {
        C1p = nullptr;
    }
    if (!K0) {
        K0p = nullptr;
    }
    if (!K2) {
        K2p = nullptr;
    }
    if (!A) {
        Ap = nullptr;
    }
    if (!B) {
        Bp = nullptr;
    }
    if (!C) {
        Cp = nullptr;
    }
    if (!D) {
        Dp = nullptr;
    }
    return CreateBicycle(fbb, v_, Mp, C1p, K0p, K2p,
            Ap, Bp, Cp, Dp);
}

flatbuffers::Offset<::fbs::Kalman> create_kalman(
        flatbuffers::FlatBufferBuilder& fbb,
        const observer::Kalman<model::BicycleWhipple>& kalman, bool x = true,
        bool P = true, bool Q = true, bool R = true, bool K = true) {
    auto x_ = state(kalman.x());
    auto P_ = symmetric_state_matrix(kalman.P());
    auto Q_ = symmetric_state_matrix(kalman.Q());
    auto R_ = symmetric_output_matrix(kalman.R());
    auto K_ = kalman_gain_matrix(kalman.K());
    auto xp = &x_;
    auto Pp = &P_;
    auto Qp = &Q_;
    auto Rp = &R_;
    auto Kp = &K_;

    if (!x) {
        xp = nullptr;
    }
    if (!P) {
        Pp = nullptr;
    }
    if (!Q) {
        Qp = nullptr;
    }
    if (!R) {
        Rp = nullptr;
    }
    if (!K) {
        Kp = nullptr;
    }
    return CreateKalman(fbb, xp, Pp, Qp, Rp, Kp);
}


flatbuffers::Offset<::fbs::Lqr> create_lqr(
        flatbuffers::FlatBufferBuilder& fbb,
        const controller::Lqr<model::BicycleWhipple>& lqr, bool n = true,
        bool r = true, bool P = true, bool Q = true, bool R = true,
        bool K = true, bool Qi = true, bool q = true) {
    uint32_t n_ = 0;
    auto r_ = state(lqr.r());
    auto Q_ = symmetric_state_matrix(lqr.Q());
    auto R_ = symmetric_input_matrix(lqr.R());
    auto P_ = symmetric_state_matrix(lqr.P());
    auto K_ = lqr_gain_matrix(lqr.K());
    auto Qi_ = symmetric_state_matrix(lqr.Qi());
    auto q_ = state(lqr.q());
    auto rp = &r_;
    auto Qp = &Q_;
    auto Rp = &R_;
    auto Pp = &P_;
    auto Kp = &K_;
    auto Qip = &Qi_;
    auto qp = &q_;

    if (n) {
        n_ = lqr.horizon_iterations();
    }
    if (!r) {
        rp = nullptr;
    }
    if (!Q) {
        Qp = nullptr;
    }
    if (!R) {
        Rp = nullptr;
    }
    if (!P) {
        Pp = nullptr;
    }
    if (!K) {
        Kp = nullptr;
    }
    if (!Qi) {
        Qip = nullptr;
    }
    if (!q) {
        qp = nullptr;
    }
    return CreateLqr(fbb, n_, rp, Qp, Rp, Pp, Kp, Qip, qp);
}

} // namespace fbs
