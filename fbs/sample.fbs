// This file is autogenerated.
// Do not modify this file as changes may be overwritten.
// Generated with settings: OrderedDict([('n', 5), ('m', 2), ('l', 3), ('o', 2), ('p', 4)])

// available types are:
// 8 bit: byte ubyte bool
// 16 bit: short ushort
// 32 bit: int uint float
// 64 bit: long ulong double

namespace fbs;

// n, 1 (5, 1) matrix
struct State {
    x0:double;
    x1:double;
    x2:double;
    x3:double;
    x4:double;
}

// m, 1 (2, 1) matrix
struct Input {
    u0:double;
    u1:double;
}

// l, 1 (3, 1) matrix
struct Output {
    y0:double;
    y1:double;
    y2:double;
}

// p, 1 (4, 1) matrix
struct AuxiliaryState {
    x0:double;
    x1:double;
    x2:double;
    x3:double;
}

// o, o (2, 2) matrix
struct SecondOrderMatrix {
    m00:double;
    m01:double;
    m10:double;
    m11:double;
}

// m, n (2, 5) matrix
struct LqrGainMatrix {
    k00:double;
    k01:double;
    k02:double;
    k03:double;
    k04:double;
    k10:double;
    k11:double;
    k12:double;
    k13:double;
    k14:double;
}

// n, l (5, 3) matrix
struct KalmanGainMatrix {
    k00:double;
    k01:double;
    k02:double;
    k10:double;
    k11:double;
    k12:double;
    k20:double;
    k21:double;
    k22:double;
    k30:double;
    k31:double;
    k32:double;
    k40:double;
    k41:double;
    k42:double;
}

// n, n (5, 5) matrix
struct StateMatrix {
    a00:double;
    a01:double;
    a02:double;
    a03:double;
    a04:double;
    a10:double;
    a11:double;
    a12:double;
    a13:double;
    a14:double;
    a20:double;
    a21:double;
    a22:double;
    a23:double;
    a24:double;
    a30:double;
    a31:double;
    a32:double;
    a33:double;
    a34:double;
    a40:double;
    a41:double;
    a42:double;
    a43:double;
    a44:double;
}

// n, m (5, 2) matrix
struct InputMatrix {
    b00:double;
    b01:double;
    b10:double;
    b11:double;
    b20:double;
    b21:double;
    b30:double;
    b31:double;
    b40:double;
    b41:double;
}

// l, n (3, 5) matrix
struct OutputMatrix {
    c00:double;
    c01:double;
    c02:double;
    c03:double;
    c04:double;
    c10:double;
    c11:double;
    c12:double;
    c13:double;
    c14:double;
    c20:double;
    c21:double;
    c22:double;
    c23:double;
    c24:double;
}

// l, m (3, 2) matrix
struct FeedthroughMatrix {
    d00:double;
    d01:double;
    d10:double;
    d11:double;
    d20:double;
    d21:double;
}

// n, n (5, 5) symmetric matrix
struct SymmetricStateMatrix {
    q00:double;
    q01:double;
    q02:double;
    q03:double;
    q04:double;
    q11:double;
    q12:double;
    q13:double;
    q14:double;
    q22:double;
    q23:double;
    q24:double;
    q33:double;
    q34:double;
    q44:double;
}

// m, m (2, 2) symmetric matrix
struct SymmetricInputMatrix {
    r00:double;
    r01:double;
    r11:double;
}

// l, l (3, 3) symmetric matrix
struct SymmetricOutputMatrix {
    r00:double;
    r01:double;
    r02:double;
    r11:double;
    r12:double;
    r22:double;
}

table Kalman {
    state_estimate:State;
    error_covariance:SymmetricStateMatrix;
    process_noise_covariance:SymmetricStateMatrix;
    measurement_noise_covariance:SymmetricOutputMatrix;
    kalman_gain:KalmanGainMatrix;
}

table Lqr {
    horizon:uint;
    reference:State;
    state_cost:SymmetricStateMatrix;
    input_cost:SymmetricInputMatrix;
    horizon_cost:SymmetricStateMatrix;
    lqr_gain:LqrGainMatrix;
    integral_cost:SymmetricStateMatrix;
    integral:State;
}

table Bicycle {
    v:double;
    dt:double;
    M:SecondOrderMatrix;
    C1:SecondOrderMatrix;
    K0:SecondOrderMatrix;
    K2:SecondOrderMatrix;
    Ad:StateMatrix;
    Bd:InputMatrix;
    Cd:OutputMatrix;
    Dd:FeedthroughMatrix;
}

table Sample {
    timestamp:uint;
    computation_time:double;
    bicycle:Bicycle;
    kalman:Kalman;
    lqr:Lqr;
    state:State; // true state
    input:Input; // applied input
    output:Output; // output without noise
    measurement:Output; // output with noise
    auxiliary_state:AuxiliaryState; // auxiliary state
}

root_type Sample;
